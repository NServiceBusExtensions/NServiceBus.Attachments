<!--
GENERATED FILE - DO NOT EDIT
This file was generated by [MarkdownSnippets](https://github.com/SimonCropp/MarkdownSnippets).
Source File: /docs/mdsource/sql.source.md
To change this file edit the source file and then run MarkdownSnippets.
-->

# SQL Attachments

Uses a SQL Server [varbinary](https://docs.microsoft.com/en-us/sql/t-sql/data-types/binary-and-varbinary-transact-sql) to store attachments for messages.


## Usage

Two settings are required as part of the default usage:

 * A connection factory that returns an open instance of a [SqlConnection](https://msdn.microsoft.com/en-us/library/system.data.sqlclient.sqlconnection.aspx). Note that any Exception that occurs during opening the connection should be handled by the factory.
 * A default time to keep for attachments.

<!-- snippet: EnableAttachments -->
<a id='snippet-enableattachments'></a>
```cs
configuration.EnableAttachments(
    fileShare: "networkSharePath",
    timeToKeep: _ => TimeSpan.FromDays(7));
```
<sup><a href='/src/Attachments.FileShare.Tests/Snippets/Usage.cs#L7-L13' title='Snippet source file'>snippet source</a> | <a href='#snippet-enableattachments' title='Start of snippet'>anchor</a></sup>
<a id='snippet-enableattachments-1'></a>
```cs
configuration.EnableAttachments(
    connectionFactory: async () =>
    {
        var connection = new SqlConnection(connectionString);
        try
        {
            await connection.OpenAsync().ConfigureAwait(false);
            return connection;
        }
        catch
        {
            connection.Dispose();
            throw;
        }
    },
    timeToKeep: _ => TimeSpan.FromDays(7));
```
<sup><a href='/src/Attachments.Sql.Tests/Snippets/Usage.cs#L13-L32' title='Snippet source file'>snippet source</a> | <a href='#snippet-enableattachments-1' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


### Recommended Usage

Extract out the connection factory to a helper method

<!-- snippet: OpenConnection -->
<a id='snippet-openconnection'></a>
```cs
async Task<SqlConnection> OpenConnection()
{
    var connection = new SqlConnection(connectionString);
    try
    {
        await connection.OpenAsync().ConfigureAwait(false);
        return connection;
    }
    catch
    {
        connection.Dispose();
        throw;
    }
}
```
<sup><a href='/src/Attachments.Sql.Tests/Snippets/Usage.cs#L116-L133' title='Snippet source file'>snippet source</a> | <a href='#snippet-openconnection' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

Also uses the `NServiceBus.Attachments.Sql.TimeToKeep.Default` method for attachment cleanup.

This usage results in the following:

<!-- snippet: EnableAttachmentsRecommended -->
<a id='snippet-enableattachmentsrecommended'></a>
```cs
configuration.EnableAttachments(
    fileShare: "networkSharePath",
    timeToKeep: TimeToKeep.Default);
```
<sup><a href='/src/Attachments.FileShare.Tests/Snippets/Usage.cs#L15-L21' title='Snippet source file'>snippet source</a> | <a href='#snippet-enableattachmentsrecommended' title='Start of snippet'>anchor</a></sup>
<a id='snippet-enableattachmentsrecommended-1'></a>
```cs
configuration.EnableAttachments(
    connectionFactory: OpenConnection,
    timeToKeep: TimeToKeep.Default);
```
<sup><a href='/src/Attachments.Sql.Tests/Snippets/Usage.cs#L34-L40' title='Snippet source file'>snippet source</a> | <a href='#snippet-enableattachmentsrecommended-1' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


### Using ambient connectivity

Attachments can leverage the ambient SQL connectivity from either the [transport](https://docs.particular.net/transports/) and/or the [persister](https://docs.particular.net/persistence/).

If both `UseSynchronizedStorageSessionConnectivity` and `UseTransportConnectivity` are defined, the `SynchronizedStorageSession` will be used first, followed by the `TransportTransaction`.


#### Use SynchronizedStorageSession connectivity

To use the ambient [SynchronizedStorageSession persister](https://docs.particular.net/nservicebus/handlers/accessing-data.md#using-nservicebus-persistence):

<!-- snippet: UseSynchronizedStorageSessionConnectivity -->
<a id='snippet-usesynchronizedstoragesessionconnectivity'></a>
```cs
var attachments = configuration.EnableAttachments(
    OpenConnection,
    TimeToKeep.Default);
attachments.UseSynchronizedStorageSessionConnectivity();
```
<sup><a href='/src/Attachments.Sql.Tests/Snippets/Usage.cs#L69-L76' title='Snippet source file'>snippet source</a> | <a href='#snippet-usesynchronizedstoragesessionconnectivity' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

This approach attempts to use the SynchronizedStorageSession using the following steps:

 * For the current context attempt to retrieve an instance of `SynchronizedStorageSession`. If no `SynchronizedStorageSession` exists, don't continue and fall back to the [SqlConnection](https://docs.microsoft.com/en-us/dotnet/api/system.data.sqlclient.sqlconnection) retrieved by the `connectionFactory`.
 * Attempt to retrieve a property named 'Transaction' that is a [SqlTransaction](https://docs.microsoft.com/en-us/dotnet/api/system.data.sqlclient.sqltransaction) from the `SynchronizedStorageSession`. If it exists, use it for all SQL operations in the current pipeline.
 * Attempt to retrieve a property named 'Connection' that is a [SqlConnection](https://docs.microsoft.com/en-us/dotnet/api/system.data.sqlclient.sqlconnection) from the `SynchronizedStorageSession`. If it exists, use it for all SQL operations in the current pipeline.

The properties are retrieved using [reflection](https://docs.microsoft.com/en-us/dotnet/framework/reflection-and-codedom/reflection) since there is no API in NServiceBus to access SynchronizedStorageSession data via type.


#### Use transport connectivity

To use the ambient [transport transaction](https://docs.particular.net/transports/transactions):

<!-- snippet: UseTransportConnectivity -->
<a id='snippet-usetransportconnectivity'></a>
```cs
var attachments = configuration.EnableAttachments(
    OpenConnection,
    TimeToKeep.Default);
attachments.UseTransportConnectivity();
```
<sup><a href='/src/Attachments.Sql.Tests/Snippets/Usage.cs#L57-L64' title='Snippet source file'>snippet source</a> | <a href='#snippet-usetransportconnectivity' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

This approach attempts to use the transport transaction using the following steps:

 * For the current context, attempt to retrieve an instance of `TransportTransaction`. If no `TransportTransaction` exists, don't continue and fall back to using the [SqlConnection](https://docs.microsoft.com/en-us/dotnet/api/system.data.sqlclient.sqlconnection) retrieved by the `connectionFactory`.
 * Attempt to retrieve an instance of [Transaction](https://docs.microsoft.com/en-us/dotnet/api/system.transactions.transaction) from the `TransportTransaction`. If it exists, use it in [SqlConnection.EnlistTransaction](https://docs.microsoft.com/en-us/dotnet/api/system.data.sqlclient.sqlconnection.enlisttransaction) with an instance of [SqlConnection](https://docs.microsoft.com/en-us/dotnet/api/system.data.sqlclient.sqlconnection) retrieved by the `connectionFactory`. Then use that [SqlConnection](https://docs.microsoft.com/en-us/dotnet/api/system.data.sqlclient.sqlconnection) for all SQL operations in the current pipeline.
 * Attempt to retrieve an instance of [SqlTransaction](https://docs.microsoft.com/en-us/dotnet/api/system.data.sqlclient.sqltransaction) from the `TransportTransaction`. If it exists, use it for all SQL operations in the current pipeline.
 * Attempt to retrieve an instance of [SqlConnection](https://docs.microsoft.com/en-us/dotnet/api/system.data.sqlclient.sqlconnection) from the `TransportTransaction`. If it exists, use it for all SQL operations in the current pipeline.
 * Any attachments associated with a message send will be deleted after message processing.


## Installation


### Script execution runs by default at endpoint startup

To streamline development the attachment installer is, by default, executed at endpoint startup, in the same manner as all other [installers](https://docs.particular.net/nservicebus/operations/installers).

<!-- snippet: ExecuteAtStartup -->
<a id='snippet-executeatstartup'></a>
```cs
configuration.EnableInstallers();
var attachments = configuration.EnableAttachments(
    connectionFactory: OpenConnection,
    timeToKeep: TimeToKeep.Default);
```
<sup><a href='/src/Attachments.Sql.Tests/Snippets/Usage.cs#L81-L88' title='Snippet source file'>snippet source</a> | <a href='#snippet-executeatstartup' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

NOTE: Note that this is also a valid approach for higher level environments.


### Optionally take control of script execution

However in higher level environment scenarios, where standard installers are being run, but the SQL attachment installation has been executed as part of a deployment, it may be necessary to explicitly disable the attachment installer executing while leaving standard installers enabled.

<!-- snippet: DisableInstaller -->
<a id='snippet-disableinstaller'></a>
```cs
configuration.EnableInstallers();
var attachments = configuration.EnableAttachments(
    connectionFactory: OpenConnection,
    timeToKeep: TimeToKeep.Default);
attachments.DisableInstaller();
```
<sup><a href='/src/Attachments.Sql.Tests/Snippets/Usage.cs#L93-L101' title='Snippet source file'>snippet source</a> | <a href='#snippet-disableinstaller' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


## Table Name

The default table name and schema is `dbo.MessageAttachments`. It can be changed with the following:

<!-- snippet: UseTableName -->
<a id='snippet-usetablename'></a>
```cs
var attachments = configuration.EnableAttachments(
    connectionFactory: OpenConnection,
    timeToKeep: TimeToKeep.Default);
attachments.UseTable(new("CustomAttachmentsTableName", "dbo"));
```
<sup><a href='/src/Attachments.Sql.Tests/Snippets/Usage.cs#L106-L113' title='Snippet source file'>snippet source</a> | <a href='#snippet-usetablename' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->



 <!-- include: attachments. path: /docs/mdsource/attachments.include.md -->

## Data Cleanup

Attachment cleanup is enabled by default. It can be disabled using the following:

<!-- snippet: DisableCleanupTask -->
<a id='snippet-disablecleanuptask'></a>
```cs
var attachments = configuration.EnableAttachments(
    fileShare: "networkSharePath",
    timeToKeep: TimeToKeep.Default);
attachments.DisableCleanupTask();
```
<sup><a href='/src/Attachments.FileShare.Tests/Snippets/Usage.cs#L26-L33' title='Snippet source file'>snippet source</a> | <a href='#snippet-disablecleanuptask' title='Start of snippet'>anchor</a></sup>
<a id='snippet-disablecleanuptask-1'></a>
```cs
var attachments = configuration.EnableAttachments(
    connectionFactory: OpenConnection,
    timeToKeep: TimeToKeep.Default);
attachments.DisableCleanupTask();
```
<sup><a href='/src/Attachments.Sql.Tests/Snippets/Usage.cs#L45-L52' title='Snippet source file'>snippet source</a> | <a href='#snippet-disablecleanuptask-1' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


## Controlling attachment lifetime

When the cleanup task runs it uses the `Expiry` column to determine if a given attachment should be deleted. This column is populated when an attachment is written. When adding an attachment to an outgoing message, all methods accept an optional parameter `timeToKeep` of the type `GetTimeToKeep`. `GetTimeToKeep` is defined as:

```
public delegate TimeSpan GetTimeToKeep(TimeSpan? messageTimeToBeReceived);
```

Where `messageTimeToBeReceived` is value of [TimeToBeReceived](https://docs.particular.net/nservicebus/messaging/discard-old-messages.md). If no `timeToKeep` parameter for a specific attachment is defined then the endpoint level `timeToKeep` is used.

The result of `timeToKeep` is then added to the current date and persisted to the `Expiry` column.

The method `TimeToKeep.Default` provides a recommended default for for attachment lifetime calculation:

 * If [TimeToBeReceived](https://docs.particular.net/nservicebus/messaging/discard-old-messages.md) is defined then keep attachment for twice that time.
 * Else; keep for 10 days.


## Reading and writing attachments


### Writing attachments to an outgoing message

Approaches to using attachments for an outgoing message.

Note: [Stream.Dispose](https://msdn.microsoft.com/en-us/library/ms227422.aspx) is called after the data has been persisted. As such it is not necessary for any code using attachments to perform this cleanup.

While the below examples illustrate adding an attachment to `SendOptions`, equivalent operations can be performed on `PublishOptions` and `ReplyOptions`


#### Factory Approach

The recommended approach for adding an attachment is by providing a delegate that constructs the stream. The execution of this delegate is then deferred until later in the outgoing pipeline, when the instance of the stream is required to be persisted.

There are both async and sync variants.

<!-- snippet: OutgoingFactory -->
<a id='snippet-outgoingfactory'></a>
```cs
class HandlerFactory :
    IHandleMessages<MyMessage>
{
    public Task Handle(MyMessage message, IMessageHandlerContext context)
    {
        var sendOptions = new SendOptions();
        var attachments = sendOptions.Attachments();
        attachments.Add(
            name: "attachment1",
            streamFactory: () => File.OpenRead("FilePath.txt"));
        return context.Send(new OtherMessage(), sendOptions);
    }
}
```
<sup><a href='/src/Attachments.FileShare.Tests/Snippets/Outgoing.cs#L3-L19' title='Snippet source file'>snippet source</a> | <a href='#snippet-outgoingfactory' title='Start of snippet'>anchor</a></sup>
<a id='snippet-outgoingfactory-1'></a>
```cs
class HandlerFactory :
    IHandleMessages<MyMessage>
{
    public Task Handle(MyMessage message, IMessageHandlerContext context)
    {
        var sendOptions = new SendOptions();
        var attachments = sendOptions.Attachments();
        attachments.Add(
            name: "attachment1",
            streamFactory: () => File.OpenRead("FilePath.txt"));
        return context.Send(new OtherMessage(), sendOptions);
    }
}
```
<sup><a href='/src/Attachments.Sql.Tests/Snippets/Outgoing.cs#L3-L19' title='Snippet source file'>snippet source</a> | <a href='#snippet-outgoingfactory-1' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

<!-- snippet: OutgoingFactoryAsync -->
<a id='snippet-outgoingfactoryasync'></a>
```cs
class HandlerFactoryAsync :
    IHandleMessages<MyMessage>
{
    static HttpClient httpClient = new();

    public Task Handle(MyMessage message, IMessageHandlerContext context)
    {
        var sendOptions = new SendOptions();
        var attachments = sendOptions.Attachments();
        attachments.Add(
            name: "attachment1",
            streamFactory: () => httpClient.GetStreamAsync("theUrl"));
        return context.Send(new OtherMessage(), sendOptions);
    }
}
```
<sup><a href='/src/Attachments.FileShare.Tests/Snippets/Outgoing.cs#L21-L39' title='Snippet source file'>snippet source</a> | <a href='#snippet-outgoingfactoryasync' title='Start of snippet'>anchor</a></sup>
<a id='snippet-outgoingfactoryasync-1'></a>
```cs
class HandlerFactoryAsync :
    IHandleMessages<MyMessage>
{
    static HttpClient httpClient = new();

    public Task Handle(MyMessage message, IMessageHandlerContext context)
    {
        var sendOptions = new SendOptions();
        var attachments = sendOptions.Attachments();
        attachments.Add(
            name: "attachment1",
            streamFactory: () => httpClient.GetStreamAsync("theUrl"));
        return context.Send(new OtherMessage(), sendOptions);
    }
}
```
<sup><a href='/src/Attachments.Sql.Tests/Snippets/Outgoing.cs#L21-L39' title='Snippet source file'>snippet source</a> | <a href='#snippet-outgoingfactoryasync-1' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


#### Instance Approach

In some cases an instance of a stream is already available in scope and as such it can be passed directly.

<!-- snippet: OutgoingInstance -->
<a id='snippet-outgoinginstance'></a>
```cs
class HandlerInstance :
    IHandleMessages<MyMessage>
{
    public Task Handle(MyMessage message, IMessageHandlerContext context)
    {
        var sendOptions = new SendOptions();
        var attachments = sendOptions.Attachments();
        var stream = File.OpenRead("FilePath.txt");
        attachments.Add(
            name: "attachment1",
            stream: stream,
            cleanup: () => File.Delete("FilePath.txt"));
        return context.Send(new OtherMessage(), sendOptions);
    }
}
```
<sup><a href='/src/Attachments.FileShare.Tests/Snippets/Outgoing.cs#L41-L59' title='Snippet source file'>snippet source</a> | <a href='#snippet-outgoinginstance' title='Start of snippet'>anchor</a></sup>
<a id='snippet-outgoinginstance-1'></a>
```cs
class HandlerInstance :
    IHandleMessages<MyMessage>
{
    public Task Handle(MyMessage message, IMessageHandlerContext context)
    {
        var sendOptions = new SendOptions();
        var attachments = sendOptions.Attachments();
        var stream = File.OpenRead("FilePath.txt");
        attachments.Add(
            name: "attachment1",
            stream: stream,
            cleanup: () => File.Delete("FilePath.txt"));
        return context.Send(new OtherMessage(), sendOptions);
    }
}
```
<sup><a href='/src/Attachments.Sql.Tests/Snippets/Outgoing.cs#L41-L59' title='Snippet source file'>snippet source</a> | <a href='#snippet-outgoinginstance-1' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


### Reading attachments for an incoming message

Approaches to using attachments for the current incoming message.


#### Process named with a delegate

Processes an attachment with a specific name.

<!-- snippet: ProcessStream -->
<a id='snippet-processstream'></a>
```cs
class HandlerProcessStream :
    IHandleMessages<MyMessage>
{
    public async Task Handle(MyMessage message, IMessageHandlerContext context)
    {
        var attachments = context.Attachments();
        await attachments.ProcessStream(
            name: "attachment1",
            action: async stream =>
            {
                // Use the attachment stream. in this example copy to a file
                await using var fileToCopyTo = File.Create("FilePath.txt");
                await stream.CopyToAsync(fileToCopyTo);
            });
    }
}
```
<sup><a href='/src/Attachments.FileShare.Tests/Snippets/Incoming.cs#L5-L24' title='Snippet source file'>snippet source</a> | <a href='#snippet-processstream' title='Start of snippet'>anchor</a></sup>
<a id='snippet-processstream-1'></a>
```cs
class HandlerProcessStream :
    IHandleMessages<MyMessage>
{
    public async Task Handle(MyMessage message, IMessageHandlerContext context)
    {
        var attachments = context.Attachments();
        await attachments.ProcessStream(
            name: "attachment1",
            action: async stream =>
            {
                // Use the attachment stream. in this example copy to a file
                using var fileToCopyTo = File.Create("FilePath.txt");
                await stream.CopyToAsync(fileToCopyTo);
            });
    }
}
```
<sup><a href='/src/Attachments.Sql.Tests/Snippets/Incoming.cs#L5-L24' title='Snippet source file'>snippet source</a> | <a href='#snippet-processstream-1' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


#### Process all with a delegate

Processes all attachments.

<!-- snippet: ProcessStreams -->
<a id='snippet-processstreams'></a>
```cs
class HandlerProcessStreams :
    IHandleMessages<MyMessage>
{
    public Task Handle(MyMessage message, IMessageHandlerContext context)
    {
        var attachments = context.Attachments();
        return attachments.ProcessStreams(
            action: async stream =>
            {
                // Use the attachment stream. in this example copy to a file
                await using var file = File.Create($"{stream.Name}.txt");
                await stream.CopyToAsync(file);
            });
    }
}
```
<sup><a href='/src/Attachments.FileShare.Tests/Snippets/Incoming.cs#L26-L44' title='Snippet source file'>snippet source</a> | <a href='#snippet-processstreams' title='Start of snippet'>anchor</a></sup>
<a id='snippet-processstreams-1'></a>
```cs
class HandlerProcessStreams :
    IHandleMessages<MyMessage>
{
    public async Task Handle(MyMessage message, IMessageHandlerContext context)
    {
        var attachments = context.Attachments();
        await attachments.ProcessStreams(
                action: async stream =>
                {
                    // Use the attachment stream. in this example copy to a file
                    using var file = File.Create($"{stream.Name}.txt");
                    await stream.CopyToAsync(file);
                })
            .ConfigureAwait(false);
    }
}
```
<sup><a href='/src/Attachments.Sql.Tests/Snippets/Incoming.cs#L26-L45' title='Snippet source file'>snippet source</a> | <a href='#snippet-processstreams-1' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


#### Copy to a stream

Copy an attachment with a specific name to another stream.

<!-- snippet: CopyTo -->
<a id='snippet-copyto'></a>
```cs
class HandlerCopyTo :
    IHandleMessages<MyMessage>
{
    public async Task Handle(MyMessage message, IMessageHandlerContext context)
    {
        var attachments = context.Attachments();
        await using var fileToCopyTo = File.Create("FilePath.txt");
        await attachments.CopyTo("attachment1", fileToCopyTo);
    }
}
```
<sup><a href='/src/Attachments.FileShare.Tests/Snippets/Incoming.cs#L67-L80' title='Snippet source file'>snippet source</a> | <a href='#snippet-copyto' title='Start of snippet'>anchor</a></sup>
<a id='snippet-copyto-1'></a>
```cs
class HandlerCopyTo :
    IHandleMessages<MyMessage>
{
    public async Task Handle(MyMessage message, IMessageHandlerContext context)
    {
        var attachments = context.Attachments();
        using var fileToCopyTo = File.Create("FilePath.txt");
        await attachments.CopyTo("attachment1", fileToCopyTo);
    }
}
```
<sup><a href='/src/Attachments.Sql.Tests/Snippets/Incoming.cs#L69-L82' title='Snippet source file'>snippet source</a> | <a href='#snippet-copyto-1' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


#### Get an instance of a stream

Get a stream for an attachment with a specific name.

<!-- snippet: GetStream -->
<a id='snippet-getstream'></a>
```cs
class HandlerGetStream :
    IHandleMessages<MyMessage>
{
    public async Task Handle(MyMessage message, IMessageHandlerContext context)
    {
        var attachments = context.Attachments();
        await using var stream = await attachments.GetStream("attachment1");
        // Use the attachment stream. in this example copy to a file
        await using var fileToCopyTo = File.Create("FilePath.txt");
        await stream.CopyToAsync(fileToCopyTo);
    }
}
```
<sup><a href='/src/Attachments.FileShare.Tests/Snippets/Incoming.cs#L97-L112' title='Snippet source file'>snippet source</a> | <a href='#snippet-getstream' title='Start of snippet'>anchor</a></sup>
<a id='snippet-getstream-1'></a>
```cs
class HandlerGetStream :
    IHandleMessages<MyMessage>
{
    public async Task Handle(MyMessage message, IMessageHandlerContext context)
    {
        var attachments = context.Attachments();
        using var attachment = await attachments.GetStream("attachment1");
        // Use the attachment stream. in this example copy to a file
        using var fileToCopyTo = File.Create("FilePath.txt");
        await attachment.CopyToAsync(fileToCopyTo);
    }
}
```
<sup><a href='/src/Attachments.Sql.Tests/Snippets/Incoming.cs#L99-L114' title='Snippet source file'>snippet source</a> | <a href='#snippet-getstream-1' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


#### Get data as bytes

Get a byte array for an attachment with a specific name.

WARNING: This should only be used the the data size is know to be small as it causes the full size of the attachment to be allocated in memory.

<!-- snippet: GetBytes -->
<a id='snippet-getbytes'></a>
```cs
class HandlerGetBytes :
    IHandleMessages<MyMessage>
{
    public async Task Handle(MyMessage message, IMessageHandlerContext context)
    {
        var attachments = context.Attachments();
        var bytes = await attachments.GetBytes("attachment1");
        // use the byte array
    }
}
```
<sup><a href='/src/Attachments.FileShare.Tests/Snippets/Incoming.cs#L82-L95' title='Snippet source file'>snippet source</a> | <a href='#snippet-getbytes' title='Start of snippet'>anchor</a></sup>
<a id='snippet-getbytes-1'></a>
```cs
class HandlerGetBytes :
    IHandleMessages<MyMessage>
{
    public async Task Handle(MyMessage message, IMessageHandlerContext context)
    {
        var attachments = context.Attachments();
        var bytes = await attachments.GetBytes("attachment1");
        // use the byte array
    }
}
```
<sup><a href='/src/Attachments.Sql.Tests/Snippets/Incoming.cs#L84-L97' title='Snippet source file'>snippet source</a> | <a href='#snippet-getbytes-1' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


### Reading attachments for a specific message

All of the above examples have companion methods that are suffixed with `ForMessage`. These methods allow a handler or saga to read any attachments as long as the message id for that attachment is known. For example processing all attachments for a specific message could be done as follows

<!-- snippet: ProcessStreamsForMessage -->
<a id='snippet-processstreamsformessage'></a>
```cs
class HandlerProcessStreamsForMessage :
    IHandleMessages<MyMessage>
{
    public Task Handle(MyMessage message, IMessageHandlerContext context)
    {
        var attachments = context.Attachments();
        return attachments.ProcessStreamsForMessage(
            messageId: "theMessageId",
            action: async stream =>
            {
                // Use the attachment stream. in this example copy to a file
                await using var toCopyTo = File.Create($"{stream.Name}.txt");
                await stream.CopyToAsync(toCopyTo);
            });
    }
}
```
<sup><a href='/src/Attachments.FileShare.Tests/Snippets/Incoming.cs#L46-L65' title='Snippet source file'>snippet source</a> | <a href='#snippet-processstreamsformessage' title='Start of snippet'>anchor</a></sup>
<a id='snippet-processstreamsformessage-1'></a>
```cs
class HandlerProcessStreamsForMessage :
    IHandleMessages<MyMessage>
{
    public async Task Handle(MyMessage message, IMessageHandlerContext context)
    {
        var attachments = context.Attachments();
        await attachments.ProcessStreamsForMessage(
                messageId: "theMessageId",
                action: async stream =>
                {
                    // Use the attachment stream. in this example copy to a file
                    using var file = File.Create($"{stream.Name}.txt");
                    await stream.CopyToAsync(file);
                })
            .ConfigureAwait(false);
    }
}
```
<sup><a href='/src/Attachments.Sql.Tests/Snippets/Incoming.cs#L47-L67' title='Snippet source file'>snippet source</a> | <a href='#snippet-processstreamsformessage-1' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

This can be helpful in a saga that is operating in a [Scatter-Gather](https://www.enterpriseintegrationpatterns.com/patterns/messaging/BroadcastAggregate.html) mode. So instead of storing all binaries inside the saga persister, the saga can instead store the message ids and then, at a latter point in time, access those attachments.


## Unit Testing

The below examples also use the [NServiceBus.Testing](https://docs.particular.net/nservicebus/testing/) extension.


### Testing outgoing attachments

<!-- snippet: TestOutgoingHandler -->
<a id='snippet-testoutgoinghandler'></a>
```cs
public class Handler :
    IHandleMessages<MyMessage>
{
    public Task Handle(MyMessage message, IMessageHandlerContext context)
    {
        var options = new SendOptions();
        var attachments = options.Attachments();
        attachments.Add("theName", () => File.OpenRead("aFilePath"));
        return context.Send(new OtherMessage(), options);
    }
}
```
<sup><a href='/src/Attachments.FileShare.Tests/Snippets/TestingOutgoing.cs#L5-L19' title='Snippet source file'>snippet source</a> | <a href='#snippet-testoutgoinghandler' title='Start of snippet'>anchor</a></sup>
<a id='snippet-testoutgoinghandler-1'></a>
```cs
public class Handler :
    IHandleMessages<MyMessage>
{
    public Task Handle(MyMessage message, IMessageHandlerContext context)
    {
        var options = new SendOptions();
        var attachments = options.Attachments();
        attachments.Add("theName", () => File.OpenRead("aFilePath"));
        return context.Send(new OtherMessage(), options);
    }
}
```
<sup><a href='/src/Attachments.Sql.Tests/Snippets/TestingOutgoing.cs#L5-L19' title='Snippet source file'>snippet source</a> | <a href='#snippet-testoutgoinghandler-1' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

<!-- snippet: TestOutgoing -->
<a id='snippet-testoutgoing'></a>
```cs
[Fact]
public async Task TestOutgoingAttachments()
{
    //Arrange
    var context = new TestableMessageHandlerContext();
    var handler = new Handler();

    //Act
    await handler.Handle(new(), context);

    // Assert
    var sentMessage = context.SentMessages.Single();
    var attachments = sentMessage.Options.Attachments();
    var names = attachments.Names;
    Assert.Single(names);
    Assert.Contains("theName", names);
    Assert.True(attachments.HasPendingAttachments);
}
```
<sup><a href='/src/Attachments.FileShare.Tests/Snippets/TestingOutgoing.cs#L21-L42' title='Snippet source file'>snippet source</a> | <a href='#snippet-testoutgoing' title='Start of snippet'>anchor</a></sup>
<a id='snippet-testoutgoing-1'></a>
```cs
[Fact]
public async Task TestOutgoingAttachments()
{
    //Arrange
    var context = new TestableMessageHandlerContext();
    var handler = new Handler();

    //Act
    await handler.Handle(new(), context);

    // Assert
    var sentMessage = context.SentMessages.Single();
    var attachments = sentMessage.Options.Attachments();
    var names = attachments.Names;
    Assert.Single(names);
    Assert.Contains("theName", names);
    Assert.True(attachments.HasPendingAttachments);
}
```
<sup><a href='/src/Attachments.Sql.Tests/Snippets/TestingOutgoing.cs#L21-L42' title='Snippet source file'>snippet source</a> | <a href='#snippet-testoutgoing-1' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


### Testing incoming attachments


#### Injecting a custom instance

To mock or verify incoming attachments is it necessary to inject a instance of `IMessageAttachments` into the current `IMessageHandlerContext`. This can be done using the `MockAttachmentHelper.InjectAttachmentsInstance()` extension method which exists in the `NServiceBus.Attachments.Testing` namespace.

<!-- snippet: InjectAttachmentsInstance -->
<a id='snippet-injectattachmentsinstance'></a>
```cs
var context = new TestableMessageHandlerContext();
var mockMessageAttachments = new MyMessageAttachments();
context.InjectAttachmentsInstance(mockMessageAttachments);
```
<sup><a href='/src/Attachments.FileShare.Tests/Snippets/TestingIncoming.cs#L11-L17' title='Snippet source file'>snippet source</a> | <a href='#snippet-injectattachmentsinstance' title='Start of snippet'>anchor</a></sup>
<a id='snippet-injectattachmentsinstance-1'></a>
```cs
var context = new TestableMessageHandlerContext();
var mockMessageAttachments = new MyMessageAttachments();
context.InjectAttachmentsInstance(mockMessageAttachments);
```
<sup><a href='/src/Attachments.Sql.Tests/Snippets/TestingIncoming.cs#L11-L17' title='Snippet source file'>snippet source</a> | <a href='#snippet-injectattachmentsinstance-1' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

The implementation of `IMessageHandlerContext` can be a custom coded mock or constructed using any of the popular mocking/assertion frameworks.

There is a default implementation of `IMessageAttachments` named  `MockMessageAttachments`. This implementation stubs out all methods. All members are virtual so it can be used as simplified base class for custom mocks.

<!-- snippet: CustomMockMessageAttachments -->
<a id='snippet-custommockmessageattachments'></a>
```cs
public class CustomMockMessageAttachments :
    MockMessageAttachments
{
    public override Task<AttachmentBytes> GetBytes(
        CancellationToken cancellation = default)
    {
        GetBytesWasCalled = true;
        return Task.FromResult(new AttachmentBytes("name", new byte[] {5}));
    }

    public bool GetBytesWasCalled { get; private set; }
}
```
<sup><a href='/src/Attachments.FileShare.Tests/Snippets/TestingIncoming.cs#L23-L38' title='Snippet source file'>snippet source</a> | <a href='#snippet-custommockmessageattachments' title='Start of snippet'>anchor</a></sup>
<a id='snippet-custommockmessageattachments-1'></a>
```cs
public class CustomMockMessageAttachments :
    MockMessageAttachments
{
    public override Task<AttachmentBytes> GetBytes(
        CancellationToken cancellation = default)
    {
        GetBytesWasCalled = true;
        return Task.FromResult(new AttachmentBytes("name", new byte[] {5}));
    }

    public bool GetBytesWasCalled { get; private set; }
}
```
<sup><a href='/src/Attachments.Sql.Tests/Snippets/TestingIncoming.cs#L23-L38' title='Snippet source file'>snippet source</a> | <a href='#snippet-custommockmessageattachments-1' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

Putting these parts together allows a handler, using incoming attachments, to be tested.

<!-- snippet: TestIncomingHandler -->
<a id='snippet-testincominghandler'></a>
```cs
public class Handler :
    IHandleMessages<MyMessage>
{
    public async Task Handle(MyMessage message, IMessageHandlerContext context)
    {
        var attachment = context.Attachments();
        var bytes = await attachment.GetBytes();
    }
}
```
<sup><a href='/src/Attachments.FileShare.Tests/Snippets/TestingIncoming.cs#L40-L52' title='Snippet source file'>snippet source</a> | <a href='#snippet-testincominghandler' title='Start of snippet'>anchor</a></sup>
<a id='snippet-testincominghandler-1'></a>
```cs
public class Handler :
    IHandleMessages<MyMessage>
{
    public async Task Handle(MyMessage message, IMessageHandlerContext context)
    {
        var attachment = context.Attachments();
        var bytes = await attachment.GetBytes();
    }
}
```
<sup><a href='/src/Attachments.Sql.Tests/Snippets/TestingIncoming.cs#L40-L52' title='Snippet source file'>snippet source</a> | <a href='#snippet-testincominghandler-1' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

<!-- snippet: TestIncoming -->
<a id='snippet-testincoming'></a>
```cs
[Fact]
public async Task TestIncomingAttachment()
{
    //Arrange
    var context = new TestableMessageHandlerContext();
    var handler = new Handler();
    var mockMessageAttachments = new CustomMockMessageAttachments();
    context.InjectAttachmentsInstance(mockMessageAttachments);

    //Act
    await handler.Handle(new(), context);

    //Assert
    Assert.True(mockMessageAttachments.GetBytesWasCalled);
}
```
<sup><a href='/src/Attachments.FileShare.Tests/Snippets/TestingIncoming.cs#L54-L72' title='Snippet source file'>snippet source</a> | <a href='#snippet-testincoming' title='Start of snippet'>anchor</a></sup>
<a id='snippet-testincoming-1'></a>
```cs
[Fact]
public async Task TestIncomingAttachment()
{
    //Arrange
    var context = new TestableMessageHandlerContext();
    var handler = new Handler();
    var mockMessageAttachments = new CustomMockMessageAttachments();
    context.InjectAttachmentsInstance(mockMessageAttachments);

    //Act
    await handler.Handle(new(), context);

    //Assert
    Assert.True(mockMessageAttachments.GetBytesWasCalled);
}
```
<sup><a href='/src/Attachments.Sql.Tests/Snippets/TestingIncoming.cs#L54-L72' title='Snippet source file'>snippet source</a> | <a href='#snippet-testincoming-1' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->
<!-- endInclude -->
